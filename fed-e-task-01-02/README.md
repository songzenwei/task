# 简答题

# 一、请说出下列最终的执行结果，并解释为什么。

    var a = [];
    for (var i = 0; i < 10; i++) {
        a[i] = function () {
            console.log(i);
        };
    }

    a[6](); //10
#   输出：10
#   解析：因为ishi全局的，i++每次执行都会操作同一个作用域下的 i，所以当 for 循环完成之后 i 变为了 10 此时打印结果就为 10

# 二、请说出下列最终的执行结果，并解释为什么。
    var tmp = 123;
    if (true) {
        console.log(tmp);
        let tmp;
    }
#   输出：报错Cannot access 'tmp' before initialization
#   解析：报错Cannot access 'tmp' before initialization,只要块级作用域内存在let命令，它所声明的变量就“绑定”这个区域，不再受外部的影响。而let命令不存在变量提升所以报错，总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的，尽管代码块外也存在相同全局变量。

# 三、结合Es6新语法，用最简单的方式找出数组中的最小值。
    
    var arr = [12, 34, 32, 89, 4];
    var minNumber = Math.min(...arr)
    console.log(minNumber) //4
#   输出：4

# 四、请详细说明var，let，const 三种变了声明的方式之间的集体差别
    var 全局作用域 声明的变量在外部也可以访问，存在变量提升
    let 块作用域，声明的变量只能在当前块作用域使用，外部无法访问，不存在变量提升
    const 块作用域，声明的变量只能在当前块作用域使用，外部无法访问，不存在变量提升，只读的，声明后不能再去更改新的内存地址

# 五、请输入下列代码最终的输出的结果，并解释为什么
    var a = 10;
    var obj = {
    a: 20,
    fn() {
        setTimeout(() => {
        console.log(this);
        });
    },
    };

    obj.fn()
#   输出：20
#   解析：普通函数的this指向调用它的对象

# 六、  简述Symbol类型的作用
#   1.用于创建独一无二的值，可做唯一key用于缓存等场景
#   2.用于创建类的私有变量,利用symbol属性不能被枚举的特性声明作为私有属性
#   3.用来重置对象的属性，比如 Symbol.toStringTag
#   4.可实现 Symbol.iterator迭代器， 让普通对象变为可迭代对象
#   5使用Symbol.for(‘xxx’)获取全局的symbol值


# 七、说说什么是浅拷贝，什么是深拷贝
#   浅拷贝：也就是拷贝A对象里面的数据，引用地址相同
#   深拷贝：会克隆出一个对象，数据相同，但是引用地址不同

# 八、请简述Typescript和script之间的关系
#   javaScript是弱类型，Typescript是强类型
#   TypeScript是一种由微软开发的自由和开源的编程语言。它是JavaScript的一个超集。
#   TypeScript增加了静态类型、类、模块、接口和类型注解
#   JavaScript能够直接在浏览器引擎和node.js上直接运行，但是TypeScript不可以

# 九、你认为的TypeScript的优缺点
# 优点：
# （1）增强代码的可读性和可维护性，强类型的系统相当于最好的文档，在编译时即可发现大部分的错误，增强编辑器的功能。
# （2）包容性，js文件可以直接改成 ts 文件，不定义类型可自动推论类型，可以定义几乎一切类型，ts 编译报错时也可以生成 js 文件，兼容第三方库，即使不是用ts编写的
# （3）有活跃的社区，大多数的第三方库都可提供给 ts 的类型定义文件，完全支持 es6 规范
# 缺点：
# （1）增加学习成本，需要理解接口（Interfaces）和泛型（Generics），类（class），枚举类型（Enums）
# （2）短期增加开发成本，增加类型定义，但减少维护成本
# （3）ts 集成到构建流程需要一定的工作量
# （4）和有些库结合时不是很完美

# 十、描述引用计数的工作原理和优缺点
# 对于一个对象A,只要有任何一个对象引用了A,则A的引用计数器就加1;当引用失效时,引用计数器就减1。只要对象A的引用计数器的值为0,即表示对象A不可能再被使用,可进行回收。
# 优点
#   实现简单,垃圾对象便于辨识;判定效率高,回收没有延迟性
# 缺点
#   它需要单独的字段存储计数器,这样的做法增加了存储空间的开销
#   每次复制都需要更新计数器,伴随着加法和减法操作,这增加了时间开销。
#   引用计数器有一个严重的问题,即无法处理循环引用的情况
# 十一、描述标记整理算法的工作流程
#   分标记和清楚两个阶段完成
#   遍历所有对象找标记活动对象
#   遍历所有对象清除没有标记对象
#   清楚阶段会先执行整理，移动对象位置
#   减少碎片化控件，不会立即回收垃圾#

# 十二、描述V8中新生代存储区垃圾回收的流程
#   回收过程采用复制算法+标记整理
#   新生代内存区分为二个等大小空间
#   使用空间为From，空闲空间为to
#   活动对象存储与于from空间
#   标记整理后将活动对象拷贝至To
#   From与To交换空间完成释放
#   回收细节说明
#   拷贝过程中可能出现晋升
#   晋升就是将新生代对象移动至老生代
#   一轮GC还存活的新生代需要晋升
#   To空间的使用率超过25%

# 十三、描述增量标记算法在何时使用及工作原理
#   程序在标记阶段被暂停运行，等待标记完成自动运行，当遇到大块需要标记的对象时，程序需要暂停很长一段时间，对用户体验很不友好，因此采用增量标记，将一
#   大块分解为多个小块进行标记，减少每次程序暂停的时长，优化用户体验。最后标记完成后统一进行回收。










    
